//! Character set conversion utilities
//!
//! This module provides EBCDIC to UTF-8 conversion using static lookup tables
//! for performance.

use crate::options::{Codepage, UnmappablePolicy};
use copybook_core::{Error, ErrorCode, Result};
use std::collections::HashMap;
use std::sync::OnceLock;
use tracing::warn;

// EBCDIC to Unicode lookup tables for supported code pages
// Each table maps EBCDIC byte values (0-255) to Unicode code points

/// EBCDIC Code Page 037 (US/Canada) to Unicode lookup table
static CP037_TO_UNICODE: [u32; 256] = [
    0x0000, 0x0001, 0x0002, 0x0003, 0x009C, 0x0009, 0x0086, 0x007F, // 00-07
    0x0097, 0x008D, 0x008E, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 08-0F
    0x0010, 0x0011, 0x0012, 0x0013, 0x009D, 0x0085, 0x0008, 0x0087, // 10-17
    0x0018, 0x0019, 0x0092, 0x008F, 0x001C, 0x001D, 0x001E, 0x001F, // 18-1F
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x000A, 0x0017, 0x001B, // 20-27
    0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x0005, 0x0006, 0x0007, // 28-2F
    0x0090, 0x0091, 0x0016, 0x0093, 0x0094, 0x0095, 0x0096, 0x0004, // 30-37
    0x0098, 0x0099, 0x009A, 0x009B, 0x0014, 0x0015, 0x009E, 0x001A, // 38-3F
    0x0020, 0x00A0, 0x00E2, 0x00E4, 0x00E0, 0x00E1, 0x00E3,
    0x00E5, // 40-47 (space, nbsp, â, ä, à, á, ã, å)
    0x00E7, 0x00F1, 0x00A2, 0x002E, 0x003C, 0x0028, 0x002B,
    0x007C, // 48-4F (ç, ñ, ¢, ., <, (, +, |)
    0x0026, 0x00E9, 0x00EA, 0x00EB, 0x00E8, 0x00ED, 0x00EE,
    0x00EF, // 50-57 (&, é, ê, ë, è, í, î, ï)
    0x00EC, 0x00DF, 0x0021, 0x0024, 0x002A, 0x0029, 0x003B,
    0x00AC, // 58-5F (ì, ß, !, $, *, ), ;, ¬)
    0x002D, 0x002F, 0x00C2, 0x00C4, 0x00C0, 0x00C1, 0x00C3,
    0x00C5, // 60-67 (-, /, Â, Ä, À, Á, Ã, Å)
    0x00C7, 0x00D1, 0x00A6, 0x002C, 0x0025, 0x005F, 0x003E,
    0x003F, // 68-6F (Ç, Ñ, ¦, ,, %, _, >, ?)
    0x00F8, 0x00C9, 0x00CA, 0x00CB, 0x00C8, 0x00CD, 0x00CE,
    0x00CF, // 70-77 (ø, É, Ê, Ë, È, Í, Î, Ï)
    0x00CC, 0x0060, 0x003A, 0x0023, 0x0040, 0x0027, 0x003D,
    0x0022, // 78-7F (Ì, `, :, #, @, ', =, ")
    0x00D8, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 80-87 (Ø, a-g)
    0x0068, 0x0069, 0x00AB, 0x00BB, 0x00F0, 0x00FD, 0x00FE,
    0x00B1, // 88-8F (h, i, «, », ð, ý, þ, ±)
    0x00B0, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, // 90-97 (°, j-p)
    0x0071, 0x0072, 0x00AA, 0x00BA, 0x00E6, 0x00B8, 0x00C6,
    0x00A4, // 98-9F (q, r, ª, º, æ, ¸, Æ, ¤)
    0x00B5, 0x007E, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, // A0-A7 (µ, ~, s-x)
    0x0079, 0x007A, 0x00A1, 0x00BF, 0x00D0, 0x00DD, 0x00DE,
    0x00AE, // A8-AF (y, z, ¡, ¿, Ð, Ý, Þ, ®)
    0x005E, 0x00A3, 0x00A5, 0x00B7, 0x00A9, 0x00A7, 0x00B6,
    0x00BC, // B0-B7 (^, £, ¥, ·, ©, §, ¶, ¼)
    0x00BD, 0x00BE, 0x005B, 0x005D, 0x00AF, 0x00A8, 0x00B4,
    0x00D7, // B8-BF (½, ¾, [, ], ¯, ¨, ´, ×)
    0x007B, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // C0-C7 ({, A-G)
    0x0048, 0x0049, 0x00AD, 0x00F4, 0x00F6, 0x00F2, 0x00F3,
    0x00F5, // C8-CF (H, I, ­, ô, ö, ò, ó, õ)
    0x007D, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, // D0-D7 (}, J-P)
    0x0051, 0x0052, 0x00B9, 0x00FB, 0x00FC, 0x00F9, 0x00FA,
    0x00FF, // D8-DF (Q, R, ¹, û, ü, ù, ú, ÿ)
    0x005C, 0x00F7, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, // E0-E7 (\, ÷, S-X)
    0x0059, 0x005A, 0x00B2, 0x00D4, 0x00D6, 0x00D2, 0x00D3,
    0x00D5, // E8-EF (Y, Z, ², Ô, Ö, Ò, Ó, Õ)
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // F0-F7 (0-7)
    0x0038, 0x0039, 0x00B3, 0x00DB, 0x00DC, 0x00D9, 0x00DA,
    0x009F, // F8-FF (8, 9, ³, Û, Ü, Ù, Ú, control)
];

/// EBCDIC Code Page 273 (Germany/Austria) to Unicode lookup table
static CP273_TO_UNICODE: [u32; 256] = [
    0x0000, 0x0001, 0x0002, 0x0003, 0x009C, 0x0009, 0x0086, 0x007F, // 00-07
    0x0097, 0x008D, 0x008E, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 08-0F
    0x0010, 0x0011, 0x0012, 0x0013, 0x009D, 0x0085, 0x0008, 0x0087, // 10-17
    0x0018, 0x0019, 0x0092, 0x008F, 0x001C, 0x001D, 0x001E, 0x001F, // 18-1F
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x000A, 0x0017, 0x001B, // 20-27
    0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x0005, 0x0006, 0x0007, // 28-2F
    0x0090, 0x0091, 0x0016, 0x0093, 0x0094, 0x0095, 0x0096, 0x0004, // 30-37
    0x0098, 0x0099, 0x009A, 0x009B, 0x0014, 0x0015, 0x009E, 0x001A, // 38-3F
    0x0020, 0x00A0, 0x00E2, 0x007B, 0x00E0, 0x00E1, 0x00E3,
    0x00E5, // 40-47 (space, nbsp, â, {, à, á, ã, å)
    0x00E7, 0x00F1, 0x00C4, 0x002E, 0x003C, 0x0028, 0x002B,
    0x0021, // 48-4F (ç, ñ, Ä, ., <, (, +, !)
    0x0026, 0x00E9, 0x00EA, 0x00EB, 0x00E8, 0x00ED, 0x00EE,
    0x00EF, // 50-57 (&, é, ê, ë, è, í, î, ï)
    0x00EC, 0x00DF, 0x00DC, 0x0024, 0x002A, 0x0029, 0x003B,
    0x005E, // 58-5F (ì, ß, Ü, $, *, ), ;, ^)
    0x002D, 0x002F, 0x00C2, 0x005B, 0x00C0, 0x00C1, 0x00C3,
    0x00C5, // 60-67 (-, /, Â, [, À, Á, Ã, Å)
    0x00C7, 0x00D1, 0x00F6, 0x002C, 0x0025, 0x005F, 0x003E,
    0x003F, // 68-6F (Ç, Ñ, ö, ,, %, _, >, ?)
    0x00F8, 0x00C9, 0x00CA, 0x00CB, 0x00C8, 0x00CD, 0x00CE,
    0x00CF, // 70-77 (ø, É, Ê, Ë, È, Í, Î, Ï)
    0x00CC, 0x0060, 0x003A, 0x0023, 0x00A7, 0x0027, 0x003D,
    0x0022, // 78-7F (Ì, `, :, #, §, ', =, ")
    0x00D8, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 80-87 (Ø, a-g)
    0x0068, 0x0069, 0x00AB, 0x00BB, 0x00F0, 0x00FD, 0x00FE,
    0x00B1, // 88-8F (h, i, «, », ð, ý, þ, ±)
    0x00B0, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, // 90-97 (°, j-p)
    0x0071, 0x0072, 0x00AA, 0x00BA, 0x00E6, 0x00B8, 0x00C6,
    0x00A4, // 98-9F (q, r, ª, º, æ, ¸, Æ, ¤)
    0x00B5, 0x007E, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, // A0-A7 (µ, ~, s-x)
    0x0079, 0x007A, 0x00A1, 0x00BF, 0x00D0, 0x00DD, 0x00DE,
    0x00AE, // A8-AF (y, z, ¡, ¿, Ð, Ý, Þ, ®)
    0x00A2, 0x00A3, 0x00A5, 0x00B7, 0x00A9, 0x0040, 0x00B6,
    0x00BC, // B0-B7 (¢, £, ¥, ·, ©, @, ¶, ¼)
    0x00BD, 0x00BE, 0x00AC, 0x007C, 0x00AF, 0x00A8, 0x00B4,
    0x00D7, // B8-BF (½, ¾, ¬, |, ¯, ¨, ´, ×)
    0x00E4, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // C0-C7 (ä, A-G)
    0x0048, 0x0049, 0x00AD, 0x00F4, 0x00A6, 0x00F2, 0x00F3,
    0x00F5, // C8-CF (H, I, ­, ô, ¦, ò, ó, õ)
    0x00FC, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, // D0-D7 (ü, J-P)
    0x0051, 0x0052, 0x00B9, 0x00FB, 0x007D, 0x00F9, 0x00FA,
    0x00FF, // D8-DF (Q, R, ¹, û, }, ù, ú, ÿ)
    0x00D6, 0x00F7, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, // E0-E7 (Ö, ÷, S-X)
    0x0059, 0x005A, 0x00B2, 0x00D4, 0x005C, 0x00D2, 0x00D3,
    0x00D5, // E8-EF (Y, Z, ², Ô, \, Ò, Ó, Õ)
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // F0-F7 (0-7)
    0x0038, 0x0039, 0x00B3, 0x00DB, 0x005D, 0x00D9, 0x00DA,
    0x009F, // F8-FF (8, 9, ³, Û, ], Ù, Ú, control)
];

/// EBCDIC Code Page 500 (International) to Unicode lookup table
static CP500_TO_UNICODE: [u32; 256] = [
    0x0000, 0x0001, 0x0002, 0x0003, 0x009C, 0x0009, 0x0086, 0x007F, // 00-07
    0x0097, 0x008D, 0x008E, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 08-0F
    0x0010, 0x0011, 0x0012, 0x0013, 0x009D, 0x0085, 0x0008, 0x0087, // 10-17
    0x0018, 0x0019, 0x0092, 0x008F, 0x001C, 0x001D, 0x001E, 0x001F, // 18-1F
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x000A, 0x0017, 0x001B, // 20-27
    0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x0005, 0x0006, 0x0007, // 28-2F
    0x0090, 0x0091, 0x0016, 0x0093, 0x0094, 0x0095, 0x0096, 0x0004, // 30-37
    0x0098, 0x0099, 0x009A, 0x009B, 0x0014, 0x0015, 0x009E, 0x001A, // 38-3F
    0x0020, 0x00A0, 0x00E2, 0x00E4, 0x00E0, 0x00E1, 0x00E3,
    0x00E5, // 40-47 (space, nbsp, â, ä, à, á, ã, å)
    0x00E7, 0x00F1, 0x005B, 0x002E, 0x003C, 0x0028, 0x002B,
    0x0021, // 48-4F (ç, ñ, [, ., <, (, +, !)
    0x0026, 0x00E9, 0x00EA, 0x00EB, 0x00E8, 0x00ED, 0x00EE,
    0x00EF, // 50-57 (&, é, ê, ë, è, í, î, ï)
    0x00EC, 0x00DF, 0x005D, 0x0024, 0x002A, 0x0029, 0x003B,
    0x005E, // 58-5F (ì, ß, ], $, *, ), ;, ^)
    0x002D, 0x002F, 0x00C2, 0x00C4, 0x00C0, 0x00C1, 0x00C3,
    0x00C5, // 60-67 (-, /, Â, Ä, À, Á, Ã, Å)
    0x00C7, 0x00D1, 0x00A6, 0x002C, 0x0025, 0x005F, 0x003E,
    0x003F, // 68-6F (Ç, Ñ, ¦, ,, %, _, >, ?)
    0x00F8, 0x00C9, 0x00CA, 0x00CB, 0x00C8, 0x00CD, 0x00CE,
    0x00CF, // 70-77 (ø, É, Ê, Ë, È, Í, Î, Ï)
    0x00CC, 0x0060, 0x003A, 0x0023, 0x0040, 0x0027, 0x003D,
    0x0022, // 78-7F (Ì, `, :, #, @, ', =, ")
    0x00D8, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 80-87 (Ø, a-g)
    0x0068, 0x0069, 0x00AB, 0x00BB, 0x00F0, 0x00FD, 0x00FE,
    0x00B1, // 88-8F (h, i, «, », ð, ý, þ, ±)
    0x00B0, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, // 90-97 (°, j-p)
    0x0071, 0x0072, 0x00AA, 0x00BA, 0x00E6, 0x00B8, 0x00C6,
    0x00A4, // 98-9F (q, r, ª, º, æ, ¸, Æ, ¤)
    0x00B5, 0x007E, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, // A0-A7 (µ, ~, s-x)
    0x0079, 0x007A, 0x00A1, 0x00BF, 0x00D0, 0x00DD, 0x00DE,
    0x00AE, // A8-AF (y, z, ¡, ¿, Ð, Ý, Þ, ®)
    0x00A2, 0x00A3, 0x00A5, 0x00B7, 0x00A9, 0x00A7, 0x00B6,
    0x00BC, // B0-B7 (¢, £, ¥, ·, ©, §, ¶, ¼)
    0x00BD, 0x00BE, 0x00AC, 0x007C, 0x00AF, 0x00A8, 0x00B4,
    0x00D7, // B8-BF (½, ¾, ¬, |, ¯, ¨, ´, ×)
    0x007B, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // C0-C7 ({, A-G)
    0x0048, 0x0049, 0x00AD, 0x00F4, 0x00F6, 0x00F2, 0x00F3,
    0x00F5, // C8-CF (H, I, ­, ô, ö, ò, ó, õ)
    0x007D, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, // D0-D7 (}, J-P)
    0x0051, 0x0052, 0x00B9, 0x00FB, 0x00FC, 0x00F9, 0x00FA,
    0x00FF, // D8-DF (Q, R, ¹, û, ü, ù, ú, ÿ)
    0x005C, 0x00F7, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, // E0-E7 (\, ÷, S-X)
    0x0059, 0x005A, 0x00B2, 0x00D4, 0x00D6, 0x00D2, 0x00D3,
    0x00D5, // E8-EF (Y, Z, ², Ô, Ö, Ò, Ó, Õ)
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // F0-F7 (0-7)
    0x0038, 0x0039, 0x00B3, 0x00DB, 0x00DC, 0x00D9, 0x00DA,
    0x009F, // F8-FF (8, 9, ³, Û, Ü, Ù, Ú, control)
];

/// EBCDIC Code Page 1047 (Open Systems) to Unicode lookup table
static CP1047_TO_UNICODE: [u32; 256] = [
    0x0000, 0x0001, 0x0002, 0x0003, 0x009C, 0x0009, 0x0086, 0x007F, // 00-07
    0x0097, 0x008D, 0x008E, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 08-0F
    0x0010, 0x0011, 0x0012, 0x0013, 0x009D, 0x0085, 0x0008, 0x0087, // 10-17
    0x0018, 0x0019, 0x0092, 0x008F, 0x001C, 0x001D, 0x001E, 0x001F, // 18-1F
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x000A, 0x0017, 0x001B, // 20-27
    0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x0005, 0x0006, 0x0007, // 28-2F
    0x0090, 0x0091, 0x0016, 0x0093, 0x0094, 0x0095, 0x0096, 0x0004, // 30-37
    0x0098, 0x0099, 0x009A, 0x009B, 0x0014, 0x0015, 0x009E, 0x001A, // 38-3F
    0x0020, 0x00A0, 0x00E2, 0x00E4, 0x00E0, 0x00E1, 0x00E3,
    0x00E5, // 40-47 (space, nbsp, â, ä, à, á, ã, å)
    0x00E7, 0x00F1, 0x00A2, 0x002E, 0x003C, 0x0028, 0x002B,
    0x007C, // 48-4F (ç, ñ, ¢, ., <, (, +, |)
    0x0026, 0x00E9, 0x00EA, 0x00EB, 0x00E8, 0x00ED, 0x00EE,
    0x00EF, // 50-57 (&, é, ê, ë, è, í, î, ï)
    0x00EC, 0x00DF, 0x0021, 0x0024, 0x002A, 0x0029, 0x003B,
    0x00AC, // 58-5F (ì, ß, !, $, *, ), ;, ¬)
    0x002D, 0x002F, 0x00C2, 0x00C4, 0x00C0, 0x00C1, 0x00C3,
    0x00C5, // 60-67 (-, /, Â, Ä, À, Á, Ã, Å)
    0x00C7, 0x00D1, 0x00A6, 0x002C, 0x0025, 0x005F, 0x003E,
    0x003F, // 68-6F (Ç, Ñ, ¦, ,, %, _, >, ?)
    0x00F8, 0x00C9, 0x00CA, 0x00CB, 0x00C8, 0x00CD, 0x00CE,
    0x00CF, // 70-77 (ø, É, Ê, Ë, È, Í, Î, Ï)
    0x00CC, 0x0060, 0x003A, 0x0023, 0x0040, 0x0027, 0x003D,
    0x0022, // 78-7F (Ì, `, :, #, @, ', =, ")
    0x00D8, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 80-87 (Ø, a-g)
    0x0068, 0x0069, 0x00AB, 0x00BB, 0x00F0, 0x00FD, 0x00FE,
    0x00B1, // 88-8F (h, i, «, », ð, ý, þ, ±)
    0x00B0, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, // 90-97 (°, j-p)
    0x0071, 0x0072, 0x00AA, 0x00BA, 0x00E6, 0x00B8, 0x00C6,
    0x00A4, // 98-9F (q, r, ª, º, æ, ¸, Æ, ¤)
    0x00B5, 0x007E, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, // A0-A7 (µ, ~, s-x)
    0x0079, 0x007A, 0x00A1, 0x00BF, 0x00D0, 0x005B, 0x00DE,
    0x00AE, // A8-AF (y, z, ¡, ¿, Ð, [, Þ, ®)
    0x005E, 0x00A3, 0x00A5, 0x00B7, 0x00A9, 0x00A7, 0x00B6,
    0x00BC, // B0-B7 (^, £, ¥, ·, ©, §, ¶, ¼)
    0x00BD, 0x00BE, 0x00DD, 0x00A8, 0x00AF, 0x005D, 0x00B4,
    0x00D7, // B8-BF (½, ¾, Ý, ¨, ¯, ], ´, ×)
    0x007B, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // C0-C7 ({, A-G)
    0x0048, 0x0049, 0x00AD, 0x00F4, 0x00F6, 0x00F2, 0x00F3,
    0x00F5, // C8-CF (H, I, ­, ô, ö, ò, ó, õ)
    0x007D, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, // D0-D7 (}, J-P)
    0x0051, 0x0052, 0x00B9, 0x00FB, 0x00FC, 0x00F9, 0x00FA,
    0x00FF, // D8-DF (Q, R, ¹, û, ü, ù, ú, ÿ)
    0x005C, 0x00F7, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, // E0-E7 (\, ÷, S-X)
    0x0059, 0x005A, 0x00B2, 0x00D4, 0x00D6, 0x00D2, 0x00D3,
    0x00D5, // E8-EF (Y, Z, ², Ô, Ö, Ò, Ó, Õ)
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // F0-F7 (0-7)
    0x0038, 0x0039, 0x00B3, 0x00DB, 0x00DC, 0x00D9, 0x00DA,
    0x009F, // F8-FF (8, 9, ³, Û, Ü, Ù, Ú, control)
];

/// EBCDIC Code Page 1140 (US/Canada with Euro) to Unicode lookup table
static CP1140_TO_UNICODE: [u32; 256] = [
    0x0000, 0x0001, 0x0002, 0x0003, 0x009C, 0x0009, 0x0086, 0x007F, // 00-07
    0x0097, 0x008D, 0x008E, 0x000B, 0x000C, 0x000D, 0x000E, 0x000F, // 08-0F
    0x0010, 0x0011, 0x0012, 0x0013, 0x009D, 0x0085, 0x0008, 0x0087, // 10-17
    0x0018, 0x0019, 0x0092, 0x008F, 0x001C, 0x001D, 0x001E, 0x001F, // 18-1F
    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x000A, 0x0017, 0x001B, // 20-27
    0x0088, 0x0089, 0x008A, 0x008B, 0x008C, 0x0005, 0x0006, 0x0007, // 28-2F
    0x0090, 0x0091, 0x0016, 0x0093, 0x0094, 0x0095, 0x0096, 0x0004, // 30-37
    0x0098, 0x0099, 0x009A, 0x009B, 0x0014, 0x0015, 0x009E, 0x001A, // 38-3F
    0x0020, 0x00A0, 0x00E2, 0x00E4, 0x00E0, 0x00E1, 0x00E3,
    0x00E5, // 40-47 (space, nbsp, â, ä, à, á, ã, å)
    0x00E7, 0x00F1, 0x00A2, 0x002E, 0x003C, 0x0028, 0x002B,
    0x007C, // 48-4F (ç, ñ, ¢, ., <, (, +, |)
    0x0026, 0x00E9, 0x00EA, 0x00EB, 0x00E8, 0x00ED, 0x00EE,
    0x00EF, // 50-57 (&, é, ê, ë, è, í, î, ï)
    0x00EC, 0x00DF, 0x0021, 0x0024, 0x002A, 0x0029, 0x003B,
    0x00AC, // 58-5F (ì, ß, !, $, *, ), ;, ¬)
    0x002D, 0x002F, 0x00C2, 0x00C4, 0x00C0, 0x00C1, 0x00C3,
    0x00C5, // 60-67 (-, /, Â, Ä, À, Á, Ã, Å)
    0x00C7, 0x00D1, 0x00A6, 0x002C, 0x0025, 0x005F, 0x003E,
    0x003F, // 68-6F (Ç, Ñ, ¦, ,, %, _, >, ?)
    0x00F8, 0x00C9, 0x00CA, 0x00CB, 0x00C8, 0x00CD, 0x00CE,
    0x00CF, // 70-77 (ø, É, Ê, Ë, È, Í, Î, Ï)
    0x00CC, 0x0060, 0x003A, 0x0023, 0x0040, 0x0027, 0x003D,
    0x0022, // 78-7F (Ì, `, :, #, @, ', =, ")
    0x00D8, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067, // 80-87 (Ø, a-g)
    0x0068, 0x0069, 0x00AB, 0x00BB, 0x00F0, 0x00FD, 0x00FE,
    0x00B1, // 88-8F (h, i, «, », ð, ý, þ, ±)
    0x00B0, 0x006A, 0x006B, 0x006C, 0x006D, 0x006E, 0x006F, 0x0070, // 90-97 (°, j-p)
    0x0071, 0x0072, 0x00AA, 0x00BA, 0x00E6, 0x00B8, 0x00C6,
    0x00A4, // 98-9F (q, r, ª, º, æ, ¸, Æ, ¤)
    0x00B5, 0x007E, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077, 0x0078, // A0-A7 (µ, ~, s-x)
    0x0079, 0x007A, 0x00A1, 0x00BF, 0x00D0, 0x00DD, 0x00DE,
    0x00AE, // A8-AF (y, z, ¡, ¿, Ð, Ý, Þ, ®)
    0x005E, 0x00A3, 0x00A5, 0x00B7, 0x00A9, 0x00A7, 0x00B6,
    0x00BC, // B0-B7 (^, £, ¥, ·, ©, §, ¶, ¼)
    0x00BD, 0x00BE, 0x005B, 0x005D, 0x00AF, 0x00A8, 0x00B4,
    0x00D7, // B8-BF (½, ¾, [, ], ¯, ¨, ´, ×)
    0x007B, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047, // C0-C7 ({, A-G)
    0x0048, 0x0049, 0x00AD, 0x00F4, 0x00F6, 0x00F2, 0x00F3,
    0x00F5, // C8-CF (H, I, ­, ô, ö, ò, ó, õ)
    0x007D, 0x004A, 0x004B, 0x004C, 0x004D, 0x004E, 0x004F, 0x0050, // D0-D7 (}, J-P)
    0x0051, 0x0052, 0x00B9, 0x00FB, 0x00FC, 0x00F9, 0x00FA,
    0x00FF, // D8-DF (Q, R, ¹, û, ü, ù, ú, ÿ)
    0x005C, 0x00F7, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057, 0x0058, // E0-E7 (\, ÷, S-X)
    0x0059, 0x005A, 0x00B2, 0x00D4, 0x00D6, 0x00D2, 0x00D3,
    0x00D5, // E8-EF (Y, Z, ², Ô, Ö, Ò, Ó, Õ)
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037, // F0-F7 (0-7)
    0x0038, 0x0039, 0x00B3, 0x00DB, 0x00DC, 0x00D9, 0x00DA,
    0x20AC, // F8-FF (8, 9, ³, Û, Ü, Ù, Ú, €)
];

// EBCDIC zoned decimal sign tables
// These map the zone nibble (high 4 bits) to sign information

/// EBCDIC zoned decimal sign mapping
/// Maps zone nibble to (`is_signed`, `is_negative`)
static EBCDIC_ZONED_SIGNS: [(bool, bool); 16] = [
    (false, false), // 0x0_: unsigned
    (false, false), // 0x1_: unsigned
    (false, false), // 0x2_: unsigned
    (false, false), // 0x3_: unsigned
    (false, false), // 0x4_: unsigned
    (false, false), // 0x5_: unsigned
    (false, false), // 0x6_: unsigned
    (false, false), // 0x7_: unsigned
    (false, false), // 0x8_: unsigned
    (false, false), // 0x9_: unsigned
    (false, false), // 0xA_: unsigned
    (false, false), // 0xB_: unsigned
    (true, false),  // 0xC_: positive
    (true, true),   // 0xD_: negative
    (false, false), // 0xE_: unsigned
    (true, false),  // 0xF_: positive (default)
];

/// ASCII zoned decimal sign mapping
///
/// ASCII overpunch handling relies on byte-level inspection rather than the
/// zone nibble alone. Mark all entries as unsigned so any accidental use of the
/// table will surface as a validation error and force callers through the
/// dedicated ASCII overpunch helpers in `numeric`.
static ASCII_ZONED_SIGNS: [(bool, bool); 16] = [(false, false); 16];

static REV_CP037: OnceLock<HashMap<char, u8>> = OnceLock::new();
static REV_CP273: OnceLock<HashMap<char, u8>> = OnceLock::new();
static REV_CP500: OnceLock<HashMap<char, u8>> = OnceLock::new();
static REV_CP1047: OnceLock<HashMap<char, u8>> = OnceLock::new();
static REV_CP1140: OnceLock<HashMap<char, u8>> = OnceLock::new();

fn build_reverse_map(table: &[u32; 256]) -> HashMap<char, u8> {
    let mut map = HashMap::with_capacity(256);
    for (i, &code) in table.iter().enumerate() {
        if let Some(ch) = char::from_u32(code) {
            map.insert(ch, i as u8);
        }
    }
    map
}

fn get_reverse_ebcdic_table(codepage: Codepage) -> Option<&'static HashMap<char, u8>> {
    match codepage {
        Codepage::ASCII => None,
        Codepage::CP037 => Some(REV_CP037.get_or_init(|| build_reverse_map(&CP037_TO_UNICODE))),
        Codepage::CP273 => Some(REV_CP273.get_or_init(|| build_reverse_map(&CP273_TO_UNICODE))),
        Codepage::CP500 => Some(REV_CP500.get_or_init(|| build_reverse_map(&CP500_TO_UNICODE))),
        Codepage::CP1047 => Some(REV_CP1047.get_or_init(|| build_reverse_map(&CP1047_TO_UNICODE))),
        Codepage::CP1140 => Some(REV_CP1140.get_or_init(|| build_reverse_map(&CP1140_TO_UNICODE))),
    }
}

/// Get the appropriate lookup table for the given codepage
fn get_ebcdic_table(codepage: Codepage) -> Option<&'static [u32; 256]> {
    match codepage {
        Codepage::ASCII => None,
        Codepage::CP037 => Some(&CP037_TO_UNICODE),
        Codepage::CP273 => Some(&CP273_TO_UNICODE),
        Codepage::CP500 => Some(&CP500_TO_UNICODE),
        Codepage::CP1047 => Some(&CP1047_TO_UNICODE),
        Codepage::CP1140 => Some(&CP1140_TO_UNICODE),
    }
}

/// Get the appropriate zoned sign table for the given codepage
#[must_use]
#[inline]
pub fn get_zoned_sign_table(codepage: Codepage) -> &'static [(bool, bool); 16] {
    match codepage {
        Codepage::ASCII => &ASCII_ZONED_SIGNS,
        _ => &EBCDIC_ZONED_SIGNS,
    }
}

/// Convert EBCDIC bytes to UTF-8 string
///
/// # Errors
/// Returns an error if the EBCDIC data contains invalid bytes that cannot be converted.
#[inline]
#[must_use = "Handle the Result or propagate the error"]
pub fn ebcdic_to_utf8(data: &[u8], codepage: Codepage, policy: UnmappablePolicy) -> Result<String> {
    // ASCII pass-through mode (transparent 8-bit, not Windows-1252)
    if codepage == Codepage::ASCII {
        return Ok(String::from_utf8_lossy(data).into_owned());
    }

    let table = get_ebcdic_table(codepage).ok_or_else(|| {
        Error::new(
            ErrorCode::CBKC301_INVALID_EBCDIC_BYTE,
            format!("Unsupported codepage: {codepage:?}"),
        )
    })?;

    let mut result = String::with_capacity(data.len());

    for &byte in data {
        let unicode_point = table[byte as usize];

        // Check for unmappable characters (control characters < 0x20 except tab, LF, CR)
        if unicode_point < 0x20
            && unicode_point != 0x09
            && unicode_point != 0x0A
            && unicode_point != 0x0D
        {
            match policy {
                UnmappablePolicy::Error => {
                    return Err(Error::new(
                        ErrorCode::CBKC301_INVALID_EBCDIC_BYTE,
                        format!("Unmappable EBCDIC byte: 0x{byte:02X} -> U+{unicode_point:04X}"),
                    ));
                }
                UnmappablePolicy::Replace => {
                    warn!(
                        "CBKC301_INVALID_EBCDIC_BYTE: Unmappable EBCDIC byte 0x{:02X}, replacing with U+FFFD",
                        byte
                    );
                    result.push('\u{FFFD}'); // Unicode replacement character
                    continue;
                }
                UnmappablePolicy::Skip => {
                    warn!(
                        "CBKC301_INVALID_EBCDIC_BYTE: Unmappable EBCDIC byte 0x{:02X}, skipping",
                        byte
                    );
                    continue;
                }
            }
        }

        // Convert Unicode code point to char
        if let Some(ch) = char::from_u32(unicode_point) {
            result.push(ch);
        } else {
            match policy {
                UnmappablePolicy::Error => {
                    return Err(Error::new(
                        ErrorCode::CBKC301_INVALID_EBCDIC_BYTE,
                        format!("Invalid Unicode code point: U+{unicode_point:04X}"),
                    ));
                }
                UnmappablePolicy::Replace => {
                    warn!(
                        "CBKC301_INVALID_EBCDIC_BYTE: Invalid Unicode code point U+{:04X}, replacing with U+FFFD",
                        unicode_point
                    );
                    result.push('\u{FFFD}');
                }
                UnmappablePolicy::Skip => {
                    warn!(
                        "CBKC301_INVALID_EBCDIC_BYTE: Invalid Unicode code point U+{:04X}, skipping",
                        unicode_point
                    );
                }
            }
        }
    }

    Ok(result)
}

/// Convert UTF-8 string to EBCDIC bytes
///
/// # Errors
/// Returns an error if the UTF-8 text contains characters that cannot be mapped to the target codepage.
#[inline]
#[must_use = "Handle the Result or propagate the error"]
pub fn utf8_to_ebcdic(text: &str, codepage: Codepage) -> Result<Vec<u8>> {
    // ASCII pass-through mode (transparent 8-bit, not Windows-1252)
    if codepage == Codepage::ASCII {
        return Ok(text.as_bytes().to_vec());
    }

    let reverse_table = get_reverse_ebcdic_table(codepage).ok_or_else(|| {
        Error::new(
            ErrorCode::CBKC301_INVALID_EBCDIC_BYTE,
            format!("Unsupported codepage: {codepage:?}"),
        )
    })?;

    let mut result = Vec::with_capacity(text.len());

    for ch in text.chars() {
        if let Some(&ebcdic_byte) = reverse_table.get(&ch) {
            result.push(ebcdic_byte);
        } else {
            return Err(Error::new(
                ErrorCode::CBKC301_INVALID_EBCDIC_BYTE,
                format!("Character '{ch}' cannot be mapped to {codepage:?}"),
            ));
        }
    }

    Ok(result)
}

/// Get the space byte value for the given codepage.
///
/// Returns `0x20` for ASCII, `0x40` for all EBCDIC codepages.
///
/// # Example
/// ```
/// use copybook_codec::options::Codepage;
/// use copybook_codec::charset::space_byte;
///
/// assert_eq!(space_byte(Codepage::ASCII), 0x20);
/// assert_eq!(space_byte(Codepage::CP037), 0x40);
/// assert_eq!(space_byte(Codepage::CP1140), 0x40);
/// ```
#[inline]
#[must_use]
pub fn space_byte(codepage: Codepage) -> u8 {
    match codepage {
        Codepage::ASCII => 0x20,
        Codepage::CP037
        | Codepage::CP273
        | Codepage::CP500
        | Codepage::CP1047
        | Codepage::CP1140 => 0x40,
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_space_byte_ascii() {
        assert_eq!(space_byte(Codepage::ASCII), 0x20);
    }

    #[test]
    fn test_space_byte_ebcdic() {
        // All EBCDIC codepages use 0x40 for space
        assert_eq!(space_byte(Codepage::CP037), 0x40);
        assert_eq!(space_byte(Codepage::CP273), 0x40);
        assert_eq!(space_byte(Codepage::CP500), 0x40);
        assert_eq!(space_byte(Codepage::CP1047), 0x40);
        assert_eq!(space_byte(Codepage::CP1140), 0x40);
    }
}
