--- #1 ---
  Scenario: Decoding empty record (zero-length binary)
   ✔> Given ASCII codepage
   ✔  Given a copybook with content:
   ✔  And binary data: ""
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\codec_edge_cases.feature:21:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #2 ---
  Scenario: COMP-3 packed decimal with invalid nibbles
   ✔> Given ASCII codepage
   ✔  Given a copybook with content:
   ✔  And binary data: "\xFF\xFF\xFF\xFF\xFF"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\codec_edge_cases.feature:61:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #3 ---
  Scenario: DISPLAY numeric with leading spaces
   ✔> Given ASCII codepage
   ✔  Given a copybook with content:
   ✔  And binary data: "  123"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\codec_edge_cases.feature:108:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #4 ---
  Scenario: DISPLAY numeric with trailing spaces
   ✔> Given ASCII codepage
   ✔  Given a copybook with content:
   ✔  And binary data: "123  "
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\codec_edge_cases.feature:118:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #5 ---
  Scenario: PIC 9 field containing alphabetic characters
   ✔> Given ASCII codepage
   ✔  Given a copybook with content:
   ✔  And binary data: "ABCDE"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\codec_edge_cases.feature:154:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #6 ---
  Scenario: PIC 9 field containing mixed alpha-numeric
   ✔> Given ASCII codepage
   ✔  Given a copybook with content:
   ✔  And binary data: "12A45"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\codec_edge_cases.feature:164:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #7 ---
  Scenario: Decode empty binary data
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And binary data: ""
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\decode_edge_cases.feature:60:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #8 ---
  Scenario: Decode COMP-3 field with invalid nibble
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And binary data: "\xFF\xFF\xFF\xFF\xFF"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\decode_edge_cases.feature:109:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #9 ---
  Scenario: Decode ODO with Normative min_count enforcement (valid count)
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And Normative dialect
   ✔  And binary data: "005ELEMENT001ELEMENT002ELEMENT003ELEMENT004ELEMENT005"
   ✔  When the binary data is decoded
   ✔  Then decoding should succeed
   ✔  And the decoded output should contain "ELEMENT001"
   ✘  And the decoded output should contain "ELEMENT005"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:66:5
      Matched: tests\bdd\steps\encode_decode.rs:424:1
      Step panicked. Captured output: Expected decoded output to contain 'ELEMENT005', got: {"schema":"copybook.v1","record_index":1,"codepage":"ascii","fields":{"COUNT-FIELD":"005","DYNAMIC-ARRAY":[{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"}]},"COUNT-FIELD":"005","DYNAMIC-ARRAY":[{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"},{"ELEMENT":"ELEMENT001"}],"schema_fingerprint":"a7668e965ead53653b757a302a814dd0d5d8389aa727ce52aa504bb1776dca97","__schema_id":"a7668e965ead53653b757a302a814dd0d5d8389aa727ce52aa504bb1776dca97","length":53,"__record_index":1,"__length":53}

--- #10 ---
  Scenario: Decode ODO with Normative min_count enforcement (invalid count)
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And Normative dialect
   ✔  And binary data: "003ELEMENT001ELEMENT002ELEMENT003"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:79:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #11 ---
  Scenario: Decode ODO with Zero-Tolerant min_count ignored (below min_count)
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And Zero-Tolerant dialect
   ✔  And binary data: "003ELEMENT001ELEMENT002ELEMENT003"
   ✔  When the binary data is decoded
   ✔  Then decoding should succeed
   ✘  And the decoded output should contain "ELEMENT001"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:108:5
      Matched: tests\bdd\steps\encode_decode.rs:424:1
      Step panicked. Captured output: Expected decoded output to contain 'ELEMENT001', got:

--- #12 ---
  Scenario: Decode ODO with One-Tolerant min_count clamped (zero min_count)
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And One-Tolerant dialect
   ✔  And binary data: "000"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:121:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #13 ---
  Scenario: Parse copybook with complex ODO structure in different dialects
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And Normative dialect
   ✔  When the copybook is parsed
   ✘  Then the schema should be successfully parsed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:153:5
      Matched: tests\bdd\steps\parsing.rs:138:1
      Step panicked. Captured output: Schema parsing failed with error: CBKP021_ODO_NOT_TAIL: ODO array 'COMPLEX-ODO.HEADERS' must be last storage field under 'COMPLEX-ODO'

--- #14 ---
  Scenario: Integration with existing copybook parsing scenarios
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And One-Tolerant dialect
   ✔  When the copybook is parsed
   ✘  Then the schema should be successfully parsed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:195:5
      Matched: tests\bdd\steps\parsing.rs:138:1
      Step panicked. Captured output: Schema parsing failed with error: CBKP021_ODO_NOT_TAIL: ODO array 'INTEGRATION-TEST.DYNAMIC-ARRAY' must be last storage field under 'INTEGRATION-TEST'

--- #15 ---
  Scenario: Round-trip with ODO in different dialects
   ✔> Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔> And ASCII codepage
   ✔  Given a copybook with content:
   ✔  And Zero-Tolerant dialect
   ✔  And binary data: "002ELEM1ELEM2"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_lever.feature:212:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: assertion `left == right` failed: Round-trip should be lossless: original data differs from encoded data
        left: [48, 48, 50, 69, 76, 69, 77, 49, 69, 76, 69, 77, 50]
       right: []
Feature: Dialect Modes for ODO Behavior

--- #16 ---
  Scenario: Normative dialect rejects count below declared min
   ✔  Given a copybook with content:
   ✔  And Normative dialect
   ✔  And ASCII codepage
   ✔  And binary data: "002AAAABBBB"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_modes.feature:34:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #17 ---
  Scenario: Zero-tolerant dialect still respects max count
   ✔  Given a copybook with content:
   ✔  And Zero-Tolerant dialect
   ✔  And ASCII codepage
   ✔  And binary data: "005AAAABBBBCCCCDDDDEEEE"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_modes.feature:95:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #18 ---
  Scenario: One-tolerant dialect clamps min_count to 1
   ✔  Given a copybook with content:
   ✔  And One-Tolerant dialect
   ✔  When the copybook is parsed
   ✔  Then the schema should be successfully parsed
   ✘  And field ITEMS should have ODO with min 1 and max 20
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_modes.feature:110:5
      Matched: tests\bdd\steps\parsing.rs:325:1
      Step panicked. Captured output: assertion `left == right` failed: Field 'ITEMS' ODO min should be 1
        left: 0
       right: 1

--- #19 ---
  Scenario: One-tolerant dialect rejects zero count when min declared as 0
   ✔  Given a copybook with content:
   ✔  And One-Tolerant dialect
   ✔  And ASCII codepage
   ✔  And binary data: "000"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\dialect_modes.feature:124:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #20 ---
  Scenario: Encode with comma separator and decimal
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 10 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:291:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 10 bytes, got 9
        left: 9
       right: 10

--- #21 ---
  Scenario: Encode with currency symbol and comma separator
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 10 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:419:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 10 bytes, got 9
        left: 9
       right: 10

--- #22 ---
  Scenario: Encode with space insertion (E3.7)
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 7 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:438:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 7 bytes, got 0
        left: 0
       right: 7

--- #23 ---
  Scenario: Encode with multiple space insertions
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 5 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:453:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 5 bytes, got 0
        left: 0
       right: 5

--- #24 ---
  Scenario: Encode with space insertion and zero suppression
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 7 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:468:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 7 bytes, got 6
        left: 6
       right: 7

--- #25 ---
  Scenario: Encode with space insertion and decimal
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then encoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:482:5
      Matched: tests\bdd\steps\encode_decode.rs:568:1
      Step panicked. Captured output: Encoding failed with error: CBKP001_SYNTAX: Invalid level number '99' (line 3)

--- #26 ---
  Scenario: Encode with decimal and zero insert
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 5 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:517:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 5 bytes, got 0
        left: 0
       right: 5

--- #27 ---
  Scenario: Encode with value overflow should fail
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then encoding should fail
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:610:5
      Matched: tests\bdd\steps\encode_decode.rs:624:1
      Step panicked. Captured output: Encoding should fail

--- #28 ---
  Scenario: Encode with invalid character in value should fail
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then encoding should fail
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:624:5
      Matched: tests\bdd\steps\encode_decode.rs:624:1
      Step panicked. Captured output: Encoding should fail

--- #29 ---
  Scenario: Encode with empty value should fail
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then encoding should fail
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:638:5
      Matched: tests\bdd\steps\encode_decode.rs:624:1
      Step panicked. Captured output: Encoding should fail

--- #30 ---
  Scenario: Encode with multiple decimal points in value should fail
   ✔  Given a copybook with edited PIC:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then encoding should fail
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\edited_pic_encoding.feature:652:5
      Matched: tests\bdd\steps\encode_decode.rs:624:1
      Step panicked. Captured output: Encoding should fail

--- #31 ---
  Scenario: Decode numeric fields from binary
   ✔  Given a copybook with numeric fields
   ✔  And ASCII codepage
   ✔  And binary data: "000000000000000000"
   ✔  When the binary data is decoded
   ✔  Then decoding should succeed
   ✔  And the decoded output should be valid JSON
   ✘  And the decoded output should contain "PACKED-DECIMAL"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\encode_decode.feature:43:5
      Matched: tests\bdd\steps\encode_decode.rs:424:1
      Step panicked. Captured output: Expected decoded output to contain 'PACKED-DECIMAL', got:

--- #32 ---
  Scenario: Round-trip OCCURS array
   ✔  Given a copybook with OCCURS clause
   ✔  And ASCII codepage
   ✔  And binary data: "ELEMENT001ELEMENT002ELEMENT003ELEMENT004ELEMENT005"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\encode_roundtrip.feature:56:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: assertion `left == right` failed: Round-trip should be lossless: original data differs from encoded data
        left: [69, 76, 69, 77, 69, 78, 84, 48, 48, 49, 69, 76, 69, 77, 69, 78, 84, 48, 48, 50, 69, 76, 69, 77, 69, 78, 84, 48, 48, 51, 69, 76, 69, 77, 69, 78, 84, 48, 48, 52, 69, 76, 69, 77, 69, 78, 84, 48, 48, 53]
       right: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

--- #33 ---
  Scenario: Encode numeric value that overflows field capacity
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\encode_roundtrip.feature:74:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #34 ---
  Scenario: Encode string that exceeds field length
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\encode_roundtrip.feature:88:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #35 ---
  Scenario: Parse copybook with COMP-4 binary integer
   ✔  Given a copybook with COMP-4 field:
   ✔  When copybook is parsed
   ✘  Then schema should be successfully parsed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:34:5
      Matched: tests\bdd\steps\parsing.rs:493:1
      Step panicked. Captured output: Schema parsing failed with error: CBKP001_SYNTAX: Expected field name after level 5

--- #36 ---
  Scenario: Parse copybook with COMP-5 binary integer
   ✔  Given a copybook with COMP-5 field:
   ✔  When copybook is parsed
   ✘  Then schema should be successfully parsed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:44:5
      Matched: tests\bdd\steps\parsing.rs:493:1
      Step panicked. Captured output: Schema parsing failed with error: CBKP001_SYNTAX: Expected field name after level 5

--- #37 ---
  Scenario: Parse copybook with OCCURS DEPENDING ON (ODO)
   ✔  Given a copybook with ODO:
   ✔  When copybook is parsed
   ✔  Then schema should be successfully parsed
   ✘  And field "ARRAY" should have ODO with counter "COUNT"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:125:5
      Step match is ambiguous: Possible matches:
      ^field (?:"(?P<__0_0>[^"\\]*(?:\\.[^"\\]*)*)"|'(?P<__0_1>[^'\\]*(?:\\.[^'\\]*)*)') should have ODO with counter (?:"(?P<__1_0>[^"\\]*(?:\\.[^"\\]*)*)"|'(?P<__1_1>[^'\\]*(?:\\.[^'\\]*)*)')$ --> tests\bdd\steps\parsing.rs:316:1
      ^field ([^\s]+) should have ODO with counter (?:"(?P<__1_0>[^"\\]*(?:\\.[^"\\]*)*)"|'(?P<__1_1>[^'\\]*(?:\\.[^'\\]*)*)')$ --> tests\bdd\steps\parsing.rs:292:1

--- #38 ---
  Scenario: Parse copybook with nested ODO
   ✔  Given a copybook with nested ODO:
   ✔  When copybook is parsed
   ✘  Then schema should be successfully parsed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:138:5
      Matched: tests\bdd\steps\parsing.rs:493:1
      Step panicked. Captured output: Schema parsing failed with error: CBKP022_NESTED_ODO: Nested ODO not supported: field 'NESTED-ODO.OUTER-ARRAY.INNER-ARRAY' has OCCURS DEPENDING ON inside another OCCURS/ODO array

--- #39 ---
  Scenario: Encode COMP-3 packed decimal data
   ✔  Given a copybook with COMP-3 field:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And encoded length should be 4 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:224:5
      Matched: tests\bdd\steps\encode_decode.rs:641:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded length 4 bytes, got 5
        left: 5
       right: 4

--- #40 ---
  Scenario: Decode complex nested structure
   ✔  Given a copybook with nested groups:
   ✔  And ASCII codepage
   ✔  And binary data for all fields
   ✔  When binary data is decoded
   ✔  Then all fields should be decoded
   ✘  And FIELD1 should be "ABCDEFGHIJ"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:341:5
      Matched: tests\bdd\steps\encode_decode.rs:676:1
      Step panicked. Captured output: assertion `left == right` failed: Expected FIELD1='ABCDEFGHIJ', got ''
        left: ""
       right: "ABCDEFGHIJ"

--- #41 ---
  Scenario: Handle BLANK WHEN ZERO on decode
   ✔  Given a copybook with BLANK WHEN ZERO:
   ✔  And ASCII codepage
   ✔  And binary data with zero value
   ✔  When binary data is decoded
   ✘  Then decoded field AMOUNT should be blank
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:377:5
      Matched: tests\bdd\steps\encode_decode.rs:482:1
      Step panicked. Captured output: Expected decoded field 'AMOUNT' to be blank, got '0'

--- #42 ---
  Scenario: Handle BLANK WHEN ZERO on encode
   ✔  Given a copybook with BLANK WHEN ZERO:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And encoded data should be blank
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:392:5
      Matched: tests\bdd\steps\encode_decode.rs:712:1
      Step panicked. Captured output: Expected encoded data to be blank

--- #43 ---
  Scenario: Parse copybook with large OCCURS
   ✔  Given a copybook with large OCCURS:
   ✔  When copybook is parsed
   ✔  Then schema should be successfully parsed
   ✘  And field "ARRAY" should have OCCURS count 100
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\enterprise_features.feature:440:5
      Step match is ambiguous: Possible matches:
      ^field (?:"(?P<__0_0>[^"\\]*(?:\\.[^"\\]*)*)"|'(?P<__0_1>[^'\\]*(?:\\.[^'\\]*)*)') should have OCCURS count ((?:-?\d+)|(?:\d+))$ --> tests\bdd\steps\parsing.rs:283:1
      ^field ([^\s]+) should have OCCURS count ((?:-?\d+)|(?:\d+))$ --> tests\bdd\steps\parsing.rs:260:1

--- #44 ---
  Scenario: Decode binary data with invalid encoding
   ✔  Given a simple copybook with a single field
   ✔  And EBCDIC codepage
   ✔  And binary data with invalid encoding
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:37:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #45 ---
  Scenario: Encode JSON data with missing required fields
   ✔  Given a simple copybook with a single field
   ✔  And ASCII codepage
   ✔  And JSON data with missing required fields
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:44:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #46 ---
  Scenario: Encode JSON data with invalid field types
   ✔  Given a simple copybook with a single field
   ✔  And ASCII codepage
   ✔  And JSON data with invalid field types
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:51:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #47 ---
  Scenario: Parse copybook with duplicate field names
   ✔  Given a copybook with content:
   ✔  When the copybook is parsed
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:61:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #48 ---
  Scenario: Parse copybook with missing level numbers
   ✔  Given a copybook with content:
   ✔  When the copybook is parsed
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:79:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #49 ---
  Scenario: Decode with ODO count exceeding maximum
   ✔  Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔  And ASCII codepage
   ✔  And binary data: "999ABCDEFGH"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:115:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #50 ---
  Scenario: Decode with ODO count below minimum
   ✔  Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔  And ASCII codepage
   ✔  And binary data: "000ABCDEFGH"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:122:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #51 ---
  Scenario: Encode JSON with invalid ODO count
   ✔  Given a copybook with ODO (OCCURS DEPENDING ON)
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:132:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #52 ---
  Scenario: Parse copybook with Level-88 without VALUE clause
   ✔  Given a copybook with content:
   ✔  When the copybook is parsed
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:150:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #53 ---
  Scenario: Decode empty binary data
   ✔  Given a simple copybook with a single field
   ✔  And ASCII codepage
   ✔  And binary data: ""
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:157:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #54 ---
  Scenario: Encode empty JSON data
   ✔  Given a simple copybook with a single field
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_handling.feature:166:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #55 ---
  Scenario: CBKD data error on truncated record
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And binary data: "SHORT"
   ✔  When the binary data is decoded
   ✔  Then an error should occur
   ✘  And the error code should start with "CBKD"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_taxonomy.feature:70:5
      Matched: tests\bdd\steps\error_taxonomy.rs:6:1
      Step panicked. Captured output: Expected error code starting with 'CBKD', got 'CBKF221_RDW_UNDERFLOW'

--- #56 ---
  Scenario: CBKD data error on invalid COMP-3 nibble
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And binary data: "\xFF\xFF\xFF"
   ✔  When the binary data is decoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_taxonomy.feature:81:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #57 ---
  Scenario: CBKE encode error on numeric overflow
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_taxonomy.feature:98:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #58 ---
  Scenario: CBKE encode error on string length violation
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then an error should occur
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\error_taxonomy.feature:113:5
      Matched: tests\bdd\steps\error_handling.rs:6:1
      Step panicked. Captured output: An error should have occurred

--- #59 ---
  Scenario: emit_filler false with round-trip
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And emit_filler is false
   ✔  And binary data: "HELLOWORLD"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\filler_handling.feature:107:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: assertion `left == right` failed: Round-trip should be lossless: original data differs from encoded data
        left: [72, 69, 76, 76, 79, 87, 79, 82, 76, 68]
       right: [72, 69, 76, 76, 79, 0, 0, 0, 0, 0]

--- #60 ---
  Scenario: Golden fixture validation for ASCII encoding format
   ✔  Given a simple copybook with a single field
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 10 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\golden_fixtures.feature:114:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 10 bytes, got 0
        left: 0
       right: 10

--- #61 ---
  Scenario: Golden fixture validation for EBCDIC encoding format
   ✔  Given a simple copybook with a single field
   ✔  And EBCDIC codepage
   ✔  And JSON data:
   ✔  When JSON data is encoded
   ✔  Then encoding should succeed
   ✘  And the encoded output should be 10 bytes
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\golden_fixtures.feature:127:5
      Matched: tests\bdd\steps\encode_decode.rs:590:1
      Step panicked. Captured output: assertion `left == right` failed: Expected encoded output to be 10 bytes, got 0
        left: 0
       right: 10

--- #62 ---
  Scenario: Golden fixture validation for COMP-3 round-trip
   ✔  Given a copybook with content:
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When JSON data is encoded
   ✔  Then encoding should succeed
   ✔  And the round-trip should be lossless
   ✔  And decoding should succeed
   ✘  And decoded field RECORD-ID should be "0001"
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\golden_fixtures.feature:236:5
      Matched: tests\bdd\steps\encode_decode.rs:438:1
      Step panicked. Captured output: No records in decoded output
Feature: JSON Number Modes

--- #63 ---
  Scenario: Round-trip with RDW processing
   ✔  Given a copybook with content:
   ✔  And RDW record format
   ✔  And ASCII codepage
   ✔  And binary data: "\x00\x0F\x00\x00ROUNDTRIP-TEST"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\rdw_processing.feature:58:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: Encoded output not set

--- #64 ---
  Scenario: RDW with different record lengths
   ✔  Given a copybook with content:
   ✔  And RDW record format
   ✔  And ASCII codepage
   ✔  And binary data: "\x00\x05\x00\x00SHORT\x00\x10\x00\x00LONGER-DATA-HERE\x00\x0A\x00\x00MEDIUM-LEN"
   ✔  When the binary data is decoded
   ✔  Then decoding should succeed
   ✔  And the decoded output should be valid JSON
   ✘  And 3 records should be processed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\rdw_processing.feature:126:5
      Matched: tests\bdd\steps\encode_decode.rs:605:1
      Step panicked. Captured output: assertion `left == right` failed: Expected 3 records, got 0
        left: 0
       right: 3

--- #65 ---
  Scenario: Decode field with SIGN SEPARATE LEADING
   ✔  Given a copybook with SIGN SEPARATE LEADING
   ✔  And ASCII codepage
   ✔  And binary data: "-1234"
   ✔  When the binary data is decoded
   ✘  Then decoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:38:5
      Matched: tests\bdd\steps\encode_decode.rs:579:1
      Step panicked. Captured output: Decoding failed with error: CBKF221_RDW_UNDERFLOW: Incomplete record at end of file: expected 6 bytes (record 1, File ends with partial record)

--- #66 ---
  Scenario: Decode field with SIGN SEPARATE TRAILING
   ✔  Given a copybook with SIGN SEPARATE TRAILING
   ✔  And ASCII codepage
   ✔  And binary data: "1234-"
   ✔  When the binary data is decoded
   ✘  Then decoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:50:5
      Matched: tests\bdd\steps\encode_decode.rs:579:1
      Step panicked. Captured output: Decoding failed with error: CBKF221_RDW_UNDERFLOW: Incomplete record at end of file: expected 6 bytes (record 1, File ends with partial record)

--- #67 ---
  Scenario: Round-trip field with SIGN SEPARATE LEADING
   ✔  Given a copybook with SIGN SEPARATE LEADING
   ✔  And ASCII codepage
   ✔  And binary data: "-1234"
   ✔  When the data is round-tripped
   ✘  Then round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:92:5
      Matched: tests\bdd\steps\encode_decode.rs:724:1
      Step panicked. Captured output: Encoded output not set

--- #68 ---
  Scenario: Round-trip field with SIGN SEPARATE TRAILING
   ✔  Given a copybook with SIGN SEPARATE TRAILING
   ✔  And ASCII codepage
   ✔  And binary data: "1234-"
   ✔  When the data is round-tripped
   ✘  Then round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:104:5
      Matched: tests\bdd\steps\encode_decode.rs:724:1
      Step panicked. Captured output: Encoded output not set

--- #69 ---
  Scenario: Parse RENAMES R4 - Multiple REDEFINES
   ✔  Given a copybook with RENAMES R4 (multiple REDEFINES)
   ✔  When the copybook is parsed
   ✘  Then parsing should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:118:5
      Matched: tests\bdd\steps\parsing.rs:149:1
      Step panicked. Captured output: Parsing failed with error: CBKS610_RENAME_MULTIPLE_REDEFINES: RENAMES alias 'ALIAS-FIELD' spans multiple REDEFINES alternatives. Only single-alternative RENAMES is supported.

--- #70 ---
  Scenario: Parse RENAMES R5 - OCCURS with DEPENDING ON
   ✔  Given a copybook with RENAMES R5 (ODO)
   ✔  When the copybook is parsed
   ✘  Then parsing should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:131:5
      Matched: tests\bdd\steps\parsing.rs:149:1
      Step panicked. Captured output: Parsing failed with error: CBKS612_RENAME_ODO_NOT_SUPPORTED: RENAMES alias 'ALIAS-FIELD' spans ODO array 'ARRAY-FIELD'. This pattern is not supported.

--- #71 ---
  Scenario: Parse RENAMES R6 - Level-88 after RENAMES
   ✔  Given a copybook with RENAMES R6 (Level-88 after RENAMES)
   ✔  When the copybook is parsed
   ✘  Then parsing should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:147:5
      Matched: tests\bdd\steps\parsing.rs:149:1
      Step panicked. Captured output: Parsing failed with error: CBKS610_RENAME_MULTIPLE_REDEFINES: RENAMES alias 'ALIAS-FIELD' spans multiple REDEFINES alternatives. Only single-alternative RENAMES is supported.

--- #72 ---
  Scenario: Decode RENAMES R4 field
   ✔  Given a copybook with RENAMES R4
   ✔  And ASCII codepage
   ✔  And binary data: "1234567890ABCDEFGHIJ"
   ✔  When the binary data is decoded
   ✘  Then decoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:163:5
      Matched: tests\bdd\steps\encode_decode.rs:579:1
      Step panicked. Captured output: Decoding failed with error: CBKS610_RENAME_MULTIPLE_REDEFINES: RENAMES alias 'ALIAS-FIELD' spans multiple REDEFINES alternatives. Only single-alternative RENAMES is supported.

--- #73 ---
  Scenario: Encode RENAMES R4 field
   ✔  Given a copybook with RENAMES R4
   ✔  And ASCII codepage
   ✔  And JSON data:
   ✔  When the JSON data is encoded
   ✘  Then encoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:181:5
      Matched: tests\bdd\steps\encode_decode.rs:568:1
      Step panicked. Captured output: Encoding failed with error: CBKS610_RENAME_MULTIPLE_REDEFINES: RENAMES alias 'ALIAS-FIELD' spans multiple REDEFINES alternatives. Only single-alternative RENAMES is supported.

--- #74 ---
  Scenario: Round-trip RENAMES R4 field
   ✔  Given a copybook with RENAMES R4
   ✔  And ASCII codepage
   ✔  And binary data: "1234567890ABCDEFGHIJ"
   ✔  When the data is round-tripped
   ✘  Then round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:196:5
      Matched: tests\bdd\steps\encode_decode.rs:724:1
      Step panicked. Captured output: Encoded output not set

--- #75 ---
  Scenario: Decode RENAMES R5 with ODO
   ✔  Given a copybook with RENAMES R5
   ✔  And ASCII codepage
   ✔  And binary data: "003ELEM1ELEM2ELEM3"
   ✔  When the binary data is decoded
   ✘  Then decoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:210:5
      Matched: tests\bdd\steps\encode_decode.rs:579:1
      Step panicked. Captured output: Decoding failed with error: CBKS612_RENAME_ODO_NOT_SUPPORTED: RENAMES alias 'ALIAS-FIELD' spans ODO array 'ARRAY-FIELD'. This pattern is not supported.

--- #76 ---
  Scenario: Decode RENAMES R6 with Level-88
   ✔  Given a copybook with RENAMES R6
   ✔  And ASCII codepage
   ✔  And binary data: "1234567890ABCDEFGHIJ"
   ✔  When the binary data is decoded
   ✘  Then decoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:228:5
      Matched: tests\bdd\steps\encode_decode.rs:579:1
      Step panicked. Captured output: Decoding failed with error: CBKS610_RENAME_MULTIPLE_REDEFINES: RENAMES alias 'ALIAS-FIELD' spans multiple REDEFINES alternatives. Only single-alternative RENAMES is supported.

--- #77 ---
  Scenario: Combined SIGN SEPARATE and RENAMES
   ✔  Given a copybook with both SIGN SEPARATE and RENAMES
   ✔  And ASCII codepage
   ✔  And binary data: "-1234ABCD12"
   ✔  When the binary data is decoded
   ✘  Then decoding should succeed
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\sign_separate_renames.feature:243:5
      Matched: tests\bdd\steps\encode_decode.rs:579:1
      Step panicked. Captured output: Decoding failed with error: CBKS610_RENAME_MULTIPLE_REDEFINES: RENAMES alias 'ALIAS-FIELD' spans multiple REDEFINES alternatives. Only single-alternative RENAMES is supported.

--- #78 ---
  Scenario: Zoned encoding override for encode
   ✔> Given a copybook with content:
   ✔  Given ASCII codepage
   ✔  And zoned encoding override "ascii"
   ✔  And binary data: "12345"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\zoned_encoding_policies.feature:38:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: assertion `left == right` failed: Round-trip should be lossless: original data differs from encoded data
        left: [49, 50, 51, 52, 53]
       right: [49, 50, 51, 52, 69]

--- #79 ---
  Scenario: Auto encoding with round-trip
   ✔> Given a copybook with content:
   ✔  Given ASCII codepage
   ✔  And zoned encoding "auto"
   ✔  And binary data: "12345"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\zoned_encoding_policies.feature:66:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: assertion `left == right` failed: Round-trip should be lossless: original data differs from encoded data
        left: [49, 50, 51, 52, 53]
       right: [49, 50, 51, 52, 69]

--- #80 ---
  Scenario: Override none uses default
   ✔> Given a copybook with content:
   ✔  Given ASCII codepage
   ✔  And zoned encoding override "none"
   ✔  And binary data: "12345"
   ✔  When the data is round-tripped
   ✘  Then the round-trip should be lossless
      Step failed:
      Defined: ?\H:\Code\Rust\copybook-rs\tests\bdd\features\zoned_encoding_policies.feature:73:5
      Matched: tests\bdd\steps\encode_decode.rs:511:1
      Step panicked. Captured output: assertion `left == right` failed: Round-trip should be lossless: original data differs from encoded data
        left: [49, 50, 51, 52, 53]
       right: [49, 50, 51, 52, 69]

Total: 80